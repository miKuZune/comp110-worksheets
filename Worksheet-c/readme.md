Worksheet C:

Question a :
Checks if values in a list are duplicated by checking one value in the list against the rest, then the next value and so on. Also it checks if I and j are the same so that the same position in the list isn’t checked as it would return true when it isn’t what is being looked for. 
Question b:
Because it checks each number in the list n-1 amount of times before checking each number again for another lot of n-1.
Question c:
Each while loop of j only increases i by one. Therefore i is the same as n within the j for loop.
Question d:
Half as many variables to deal with?
Question e:
Yes because it can still potentially go through every position in the list, meaning it will check all values of j for all values of i. 
Question f:
Python’s inbuilt sort function is O(nlogn) time complexity. This is because it uses an insertion sort to sort lists. http://stackoverflow.com/questions/23809785/python-sorting-complexity-on-sorted-list
Question g:
O(NlogN) + n. Because this algorithm uses a sort function as well as a search function. 
Question h:
The second one is likely to run faster when the list is large because it takes less time to sort a list then go through it then it does to go through a list for each value of j and i. Also the second algorithm uses less checks as it only has to check the next value in the list as the list is sorted. 
O(NlogN) +n < o(n^2)
Question i:
A programmer might choose the slower algorithm because they do not want the list to be sorted. Maybe because the order of the list needs to stay as the order the values were input. 
